import { useRouter } from "vue-router";
import { useI18n } from "vue-i18n";
import { useQuasar, uid } from "quasar";
import { inject } from "vue";
import { convert } from "html-to-text";

import katex from "katex";
import "katex/dist/katex.min.css";

export function useIris() {
  const router = useRouter();
  const { t, locale } = useI18n({ useScope: "global" });
  const $q = useQuasar();

  const userAttributes = inject("userAttributes");
  const { userId, isAdmin } = userAttributes.value;

  const canEdit = (item) => {
    return isAdmin || item?.owner === userId;
  };
  const getIconFromQuestion = (question) => {
    if (question.type === "radio" && question.answers?.length === 2) {
      return "join_left";
    }
    const icon =
      {
        shorttext: "short_text",
        radio: "radio_button_checked",
        checkbox: "check_box",
        feedback: "rate_review",
      }[question.type] || question.type;
    return icon;
  };

  return { router, t, locale, $q, uid, canEdit, getIconFromQuestion };
}

export function useFormatter() {
  // Function to render LaTeX to HTML using KaTeX
  function renderLatexString(latexString) {
    try {
      return katex.renderToString(latexString, {
        throwOnError: false,
      });
    } catch (error) {
      console.error("Error rendering LaTeX string:", error);
      return latexString; // Return original string if there's an error
    }
  }
  function replaceHTMLEscapedChars(text) {
    return text.trim()
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&amp;/g, "&");
  }

  function renderKatex(text) {
    if (!text) return text;
    // Replace display equations
    let result = text.replace(/\\\[(.*?)\\\]/gs, (match, p1) => {
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    // Replace inline equations
    result = result.replace(/\\\((.*?)\\\)/gs, (match, p1) => {
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    // Replace inline equations
    result = result.replace(/\$\$(.*?)\$\$/gs, (match, p1) => {
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    // Replace inline equations with a single $, as long as the text is short
    result = result.replace(/\$(.*?)\$/gs, (match, p1) => {
      if (p1.length < 50) return renderLatexString(replaceHTMLEscapedChars(p1));
      return p1;
    });
    // Replace weird hybrid equation generated by GPT
    result = result.replace(/\\(\\(?:sum|frac).*?)\\\\/gs, (match, p1) => {
      return renderLatexString(replaceHTMLEscapedChars(p1));
    });
    return result;
  }

  const defaultOptions = {
    wordwrap: 100,
    formatters: {
      headingFormatter: function (elem, walk, builder) {
        const level = Math.max(1, parseInt(elem.tagName[1], 10) - 0); // Get the heading level (e.g., 1 for <h1>, 2 for <h2>)
        const hashes = "#".repeat(level); // Create the appropriate number of hashes
        builder.openBlock(elem);
        builder.addInline(`\n\n${hashes} `);
        walk(elem.children, builder);
        builder.addInline("\n");
        builder.closeBlock(elem);
      },
    },
    selectors: [
      { selector: "h1", format: "headingFormatter" },
      { selector: "h2", format: "headingFormatter" },
      { selector: "h3", format: "headingFormatter" },
      { selector: "h4", format: "headingFormatter" },
      { selector: "h5", format: "headingFormatter" },
      { selector: "h6", format: "headingFormatter" },
    ],
  };

  const formatService = {
    htmlToMarkdown: (htmlContent, options = defaultOptions) =>
      convert(htmlContent, options).replace(/\n\n/g, "\n"),
    setDefaultOptions: (options) => {
      Object.assign(defaultOptions, options);
    },
    getDefaultOptions: () => defaultOptions,
    renderLatexString,
    renderKatex,
  };

  return formatService;
}
